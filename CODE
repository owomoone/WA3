#Start

print("Welcome to 掼蛋 Guandan!")
rules = input("Would you like to go over the rules of the game? (Type Y/N): ")
if rules == "Y":
    print("\nThis is a 2v2 game, form your teams now if you have not done so yet. \nNote that players will be alternating turns based on their team.")
    print("This game uses 2 full poker decks for a total of 108 cards: each player will receive 27 cards.")
    print("\nDuring each person's turn, they are allowed to either play exactly one type of card, or pass their turn.")
    print("During one set, players must play the same type of card as the player who initiated the set, but their cards must be of a larger numeric amount than the last player.")
    print("A set ends when three consecutive players pass, the other player can then start another set with a type of their choice.")
    print("The aim of the game is to throw out all of the cards in their hand as fast as possible. The one to do so first in a match will win the match.")
    print("\nTypes of card plays include:")
    print("\t单张 Singles: One singular card")
    print("\t对子 Pairs: Two cards of the same rank")
    print("\t三同张 Triples: Three cards of the same rank")
    print("\t钢板 Plates: Two consecutive triples, e.g. three 4s and three 5s")
    print("\t三连对 Tubes: Three consecutive pairs, e.g. two 3s, two 4s and two 5s")
    print("\t三带二 Full Houses: A triple and a pair. Note that the numeric amount of this type is determined by that of the triple.")
    print("\t顺子 Straights: Five consecutive single cards, e.g. A,2,3,4,5")
    print("\t炸弹 Bombs: Four or more cards of the same rank. This type of card can be used on any type of card mentioned above. Numeric amounts of this type is determined by the rank of the card, as well as the number of cards.")
    print("\t同花顺 Straight Flushes: A straight with all cards being from the same suit. This type can beat all the types mentioned above, except bombs with 6 or more cards. This can be beated by another straight flush of greater numeric amount.")
    print("\t天王炸 Joker Bombs: The strongest card combination in the whole game. Formed by all four jokers, it can beat any other type at any given time.")
    print("\nStarting from 2 for each team, the level will increase if a member from the team wins a match. If the second team member gets second, the level will increase by 3; if they get third it increases by 2; if they get last it increases by 1.")
    print("Level Cards are the 8 cards with ranks corresponding to the current level. They are stronger in numeric amount than all cards but weaker than the jokers. The starting Level Cards are thus those with rank 2.")
    print("Wild Cards are the 2 Level Cards in each round that are of the suit Heart. They can be used as any card in the game except the jokers to form all types of plays except the joker bomb.")
    print("\nNumeric Amounts of cards in ascending (without level cards):")
    print("\t2, 3, 4, 5, 6, 7, 8, 9, 10, J, Q, K, A, Black Joker, Red Joker")
    print("\nNote that the number of cards in a player's hand will immediately be revealed to all other players if it is 10 or below.")
    print("\nA team wins the game if they are at level A and win the match of the level given that the other member does not come in last.")
    print("If the team at level A does not win the match thrice during their level's turn, they will immediately be returned to level 2.")
    
ready = input("\nType S to start the game when all players are ready: ")
if ready == "S":
    print("Great, now let's start the game!")

    

pname01 = input("Player 1 (Blue Team) please input your name: ")
pname02 = input("Player 2 (Red Team) please input your name: ")
pname03 = input("Player 3 (Blue Team) please input your name: ")
pname04 = input("Player 4 (Red Team) please input your name: ")

#MISC

def RANKSsort(array):
    sortedlast = []
    temp = []

    ascOrder = ['2','3','4','5','6','7','8','9','10','J','Q','K','A','Black Joker','Red Joker']


    for i in range(len(ascOrder)):
        for j in range(len(array)):
            if array[j].getRank() == ascOrder[i]:
                temp.append(array[j])
        sortedlast = sortedlast + SUITSsort(temp)
        temp = []

    for k in range(len(array)):
        if array[k].getRank() == 'Black Joker':
            sortedlast.append(Card('Black Joker'))
    for l in range(len(array)):
        if array[l].getRank() == 'Red Joker':
            sortedlast.append(Card('Red Joker'))
    
    return(sortedlast)

def SUITSsort(aRay):
    temp2 = []
    for i in range(len(aRay)):
        if aRay[i].getSuit() == '♠':
            temp2.append(aRay[i])
    for i in range(len(aRay)):
        if aRay[i].getSuit() == '♣':
            temp2.append(aRay[i])
    for i in range(len(aRay)):
        if aRay[i].getSuit() == '♡':
            temp2.append(aRay[i])
    for i in range(len(aRay)):
        if aRay[i].getSuit() == '♢':
            temp2.append(aRay[i])

    return(temp2)

def QUICKsort(array): # recursive
    if len(array) < 2:
        return array
    pivot = array[0] # select pivot to be front
    left_part = [] # left_part is everything smaller than pivot value
    right_part = [] # right_part is everything larger than pivot value
    for i in range(1, len(array)):
        if array[i] <= pivot: # to sort in DESCENDING ORDER, change < to >
            left_part.append(array[i])
        else:
            right_part.append(array[i])
    sorted_left = QUICKsort(left_part) 
    sorted_right = QUICKsort(right_part)
    return sorted_left + [pivot] + sorted_right

#CLASSES

import random

class Card:
    def __init__(self, erank, esuit = None):
        self.rank = erank
        self.suit = esuit
        
    def getRank(self):
        return self.rank

    def getRankButInteger(self):
        if self.rank == "J":
            return "11"
        elif self.rank == "Q":
            return "12"
        elif self.rank == "K":
            return "13"
        elif self.rank == "A":
            return "14"
        elif self.rank == "Black Joker":
            return "1000"
        elif self.rank == "Red Joker":
            return "2000"
        else:
            return self.rank
    
    def getSuit(self):
        return self.suit
    
    def reveal(self):
        if self.suit != None:
            print("{} of {}".format(self.rank,self.suit))
        else:
            print(self.rank)

class Deck: 
    ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']
    suits = ['♠', '♡', '♢', '♣', '♠', '♡', '♢', '♣']
        
    def __init__(self): 
        self.deck = [Card("Black Joker"), Card("Black Joker"), Card("Red Joker"), Card("Red Joker")]
        for i in Deck.ranks: 
            for j in Deck.suits:
                self.deck.append(Card(i, j))
                         
    def shuffle(self): 
        random.shuffle(self.deck)

    def reveal(self):
        for i in self.deck:
            i.reveal()
        
    def dealCard(self):
        return self.deck.pop()


class Player:
    def __init__(self, ename):
        self.hand = []
        self.name = ename

    def givename(self):
        return self.name

    def addtohand(self, deckname, amt):
        deckname.shuffle()
        for i in range(amt):
            self.hand.append(deckname.dealCard())
        self.hand = RANKSsort(self.hand)
        

    def showhand(self):
        c = 1
        for i in self.hand:
            if i.suit != None and c < 10:
                print("Index " + str(c) + "  | " + "{} of {}".format(i.rank,i.suit))
                c += 1
            elif i.suit != None and c >= 10:
                print("Index " + str(c) + " | " + "{} of {}".format(i.rank,i.suit))
                c += 1
            elif i.suit == None and c < 10:
                print("Index " + str(c) + "  | " + i.rank)
            else: 
                print("Index " + str(c) + " | " + i.rank)
                c += 1
        c = 1

    def playcard(self, idx1, idx2 = None, idx3 = None, idx4 = None, idx5 = None, idx6 = None, idx7 = None, idx8 = None):
        #assuming no grouping yet, all cards are single

#Singles
        if idx2 == None:
            self.hand.pop(idx1 - 1).reveal()
#Pairs
        elif idx2 != None and idx3 == None:
            indexOrder1 = QUICKsort([idx1, idx2])
            if self.hand[idx1 - 1].getRank() == self.hand[idx2 - 1].getRank():
                self.hand.pop(indexOrder1[1] - 1).reveal()
                self.hand.pop(indexOrder1[0] - 1).reveal()
#Triples
        elif idx3 != None and idx4 == None:
            indexOrder2 = QUICKsort([idx1, idx2, idx3])
            if self.hand[idx1 - 1].getRank() == self.hand[idx2 - 1].getRank() == self.hand[idx3 - 1].getRank():
                self.hand.pop(indexOrder1[2] - 1).reveal()
                self.hand.pop(indexOrder1[1] - 1).reveal()
                self.hand.pop(indexOrder1[0] - 1).reveal()
#Plates
        elif idx6 != None and idx7 == None:
            temp3 = []
            temp3.append(self.hand[idx1 - 1])
            temp3.append(self.hand[idx2 - 1])
            temp3.append(self.hand[idx3 - 1])
            temp3.append(self.hand[idx4 - 1])
            temp3.append(self.hand[idx5 - 1])
            temp3.append(self.hand[idx6 - 1])
            temp3 = RANKSsort(temp3)
            indexOrder3 = QUICKsort([idx1, idx2, idx3, idx4, idx5, idx6])
            
            if temp3[5].getSuit() != None:
                if temp3[0].getRank() == temp3[1].getRank() == temp3[2].getRank() and temp3[3].getRank() == temp3[4].getRank() == temp3[5].getRank() and int(temp3[3].getRankButInteger()) - int(temp3[2].getRankButInteger()) == 1:
                    for i in temp3:
                        i.reveal()
                    del self.hand[indexOrder3[5]-1]
                    del self.hand[indexOrder3[4]-1]
                    del self.hand[indexOrder3[3]-1]
                    del self.hand[indexOrder3[2]-1]
                    del self.hand[indexOrder3[1]-1]
                    del self.hand[indexOrder3[0]-1]

                    
#Tubes
            if temp3[5].getSuit() != None:
                if temp3[0].getRank() == temp3[1].getRank() and temp3[2].getRank() == temp3[3].getRank() and temp3[4].getRank() == temp3[5].getRank() and int(temp3[4].getRankButInteger()) - int(temp3[3].getRankButInteger()) == 1 and int(temp3[2].getRankButInteger()) - int(temp3[1].getRankButInteger()) == 1:
                    for i in temp3:
                        i.reveal()
                    del self.hand[indexOrder3[5]-1]
                    del self.hand[indexOrder3[4]-1]
                    del self.hand[indexOrder3[3]-1]
                    del self.hand[indexOrder3[2]-1]
                    del self.hand[indexOrder3[1]-1]
                    del self.hand[indexOrder3[0]-1]
                    
#Full House
        elif idx5 != None and idx6 == None:
            temp4 = []
            temp4.append(self.hand[idx1 - 1])
            temp4.append(self.hand[idx2 - 1])
            temp4.append(self.hand[idx3 - 1])
            temp4.append(self.hand[idx4 - 1])
            temp4.append(self.hand[idx5 - 1])
            temp4 = RANKSsort(temp4)
            indexOrder4 = QUICKsort([idx1, idx2, idx3, idx4, idx5])
            
            if temp4[0].getRank() == temp4[1].getRank() == temp4[2].getRank() and temp4[3].getRank() == temp4[4].getRank():
                if temp4[1].getRank() != temp4[2].getRank() or temp4[2].getRank() != temp4[3].getRank():
                    for i in temp4:
                        i.reveal()
                    del self.hand[indexOrder4[4]-1]
                    del self.hand[indexOrder4[3]-1]
                    del self.hand[indexOrder4[2]-1]
                    del self.hand[indexOrder4[1]-1]
                    del self.hand[indexOrder4[0]-1]
            if temp4[0].getRank() == temp4[1].getRank() and temp4[2].getRank() == temp4[3].getRank() == temp4[4].getRank():
                if temp4[1].getRank() != temp4[2].getRank() or temp4[2].getRank() != temp4[3].getRank():
                    for i in temp4:
                        i.reveal()
                    del self.hand[indexOrder4[4]-1]
                    del self.hand[indexOrder4[3]-1]
                    del self.hand[indexOrder4[2]-1]
                    del self.hand[indexOrder4[1]-1]
                    del self.hand[indexOrder4[0]-1]
                        
#Straight Flush
            if temp4[4].getSuit() != None and int(temp4[4].getRankButBetter()) - int(temp4[3].getRankButBetter()) == 1 and int(temp4[3].getRankButBetter()) - int(temp4[2].getRankButBetter()) == 1 and int(temp4[2].getRankButBetter()) - int(temp4[1].getRankButBetter()) == 1 and int(temp4[1].getRankButBetter()) - int(temp4[0].getRankButBetter()) == 1:
                if temp4[4].getSuit() == temp4[3].getSuit() and temp4[3].getSuit() == temp4[2].getSuit() and temp4[2].getSuit() == temp4[1].getSuit() and temp4[1].getSuit() == temp4[0].getSuit():
                    for i in temp4:
                        i.reveal()
                    del self.hand[indexOrder4[4]-1]
                    del self.hand[indexOrder4[3]-1]
                    del self.hand[indexOrder4[2]-1]
                    del self.hand[indexOrder4[1]-1]
                    del self.hand[indexOrder4[0]-1]
            
#Straight
                else:
                    for i in temp4:
                        i.reveal()
                    del self.hand[indexOrder4[4]-1]
                    del self.hand[indexOrder4[3]-1]
                    del self.hand[indexOrder4[2]-1]
                    del self.hand[indexOrder4[1]-1]
                    del self.hand[indexOrder4[0]-1]

#Bomb
#Joker Bomb

                        #ADD A BOOL(T/F) TO PASS FUNCTIONS WHEN ONE TYPE OF MOVE HAS BEEN CONFIRMED

            

#ACTUALGAMECODE===ACTUALGAMECODE===ACTUALGAMECODE===ACTUALGAMECODE#
#ACTUALGAMECODE===ACTUALGAMECODE===ACTUALGAMECODE===ACTUALGAMECODE#
#ACTUALGAMECODE===ACTUALGAMECODE===ACTUALGAMECODE===ACTUALGAMECODE#

DEALPILE = Deck()
player01 = Player(pname01)
player02 = Player(pname02)
player03 = Player(pname03)
player04 = Player(pname04)

player01.addtohand(DEALPILE, 27)
player02.addtohand(DEALPILE, 27)
player03.addtohand(DEALPILE, 27)
player04.addtohand(DEALPILE, 27)
